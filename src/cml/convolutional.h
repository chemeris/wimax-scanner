/* File convolutional.h
   
   Description: General functions used to implement convolutional encoding.   

   Copyright (C) 2006-2008, Matthew C. Valenti

   Last updated on May 22, 2008

   The functions in this file are part of the Iterative Solutions 
   Coded Modulation Library. The Iterative Solutions Coded Modulation 
   Library is free software; you can redistribute it and/or modify it 
   under the terms of the GNU Lesser General Public License as published 
   by the Free Software Foundation; either version 2.1 of the License, 
   or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
  
   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

*/



/* function that creates the transit and output vectors */
/*! Init code trallis,
	trallis state bit order 0-th bit is oldest bit in register
	\param	output_p	out		output bits tabel, MSB is 0-th generator polinom
	\param	trans_p		out		next trellis state
	\param	input				input bit
	\param	g			in		generator polynomials
	\param	KK					memory length including input bit
	\param	nn					number of generaotr polinomials
	*/
void nsc_transit(
						int		output_p[],
						int		trans_p[],
						int		input,
						const int *   g,
						int     KK,
						int     nn );


/* Function rsc_transit()

  Description: Calculates the "transition matrix" for the trellis.
  This information tells the decoder what the next state and output bits
  will be given the current state and input bit.

	Input parameters:
		input		Either 0 or 1 --- the input data bit.
		g[]			A two element vector containing the code generators.
		KK			The constraint length of the convolutional code.

	Output parameters:
		output_p[]	A vector of length max_states = 2^(KK-1) containing
		            the output symbols.
		trans_p[]   A vector of length max_states that tells the decoder
					what the next state will be given the input and current state.
	
  This function is used by turbo_decode()   */

void rsc_transit(
						int	output_p[],
						int trans_p[],
						int	input,
						int g[],
						int KK,
						int nn );







/* Function Viterbi()

  Description: Uses the Viterbi algorithm to perform hard-decision decoding of a convolutional code.

	Input parameters:
		out0[]		The output bits for each state if input is a 0 (generated by rsc_transit).
		state0[]	The next state if input is a 0 (generated by rsc_transit).
		out1[]		The output bits for each state if input is a 1 (generated by rsc_transit).
		state1[]	The next state if input is a 1 (generated by rsc_transit).
		r[]			The received signal in LLR-form. For BPSK, must be in form r = 2*a*y/(sigma^2).
		KK			The constraint length of the convolutional code.
		LL			The number of data bits.

	Output parameters:
		output_u_int[]		Hard decisions on the data bits
	
*/
void Viterbi(
				unsigned char *	output_u_int,
				const int *		out0, 
				const int *		state0, 
				const int *		out1, 
				const int *		state1,
				const float *	input_c,
				int    KK,
				int    nn,
				int    LL
				);


/* Function ViterbiTb()

  Description: Uses the Viterbi algorithm to perform hard-decision decoding of a tail-biting convolutional code.

	Input parameters:
		out0[]		The output bits for each state if input is a 0 (generated by rsc_transit).
		state0[]	The next state if input is a 0 (generated by rsc_transit).
		out1[]		The output bits for each state if input is a 1 (generated by rsc_transit).
		state1[]	The next state if input is a 1 (generated by rsc_transit).
		r[]			The received signal in LLR-form. For BPSK, must be in form r = 2*a*y/(sigma^2).
		KK			The constraint length of the convolutional code.
		LL			The number of data bits.
		depth		head and tail decoding length [Ref. W. Sung, Electronics Letters, vol. 36, no. 7]

	Output parameters:
		output_u_int[]		Hard decisions on the data bits
  
*/
void ViterbiTb(
				unsigned char *	output_u_int,
				const int *		out0, 
				const int *		state0, 
				const int *		out1, 
				const int *		state1,
				const float *	input_c,
				int    KK,
				int    nn,
				int    LL,
				int	   depth,
				float *			prev_section,
				float *			next_section,
				int *			prev_bit,
				int *			prev_state,
				float *			metric_c,	/* Set of all possible branch metrics */
				float *			rec_array   /* Received values for one trellis section */
			);
